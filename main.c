/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "main.h"



int main(void)
{
	//Настройка системы тактирования - HSE
	SystemClockInit();

	//Настройка USART
	USART6_SetInterruptEnabled(1);
	USART6_Init();

	//Тактируем порт кнопки - GPIOС
	*(volatile uint32_t*)(RCC_REG + RCC_AHB1ENR_OFFSET) |= (1 << 2);    // clocking GPIOС
	//По умолчанию уже настроен на вход, ничего большен не нужно настраивать

	//Тактируем порт светодиодов - GPIOD
	*(volatile uint32_t*)(RCC_REG + RCC_AHB1ENR_OFFSET) |= (1 << 3);    // clocking GPIOD

	//Настраиваем диоды на выход - для этого пишем соответствующие биты в регистр MODER
	//У МЕНЯ 12, 13, 14
	//IO12
	*(volatile uint32_t*)(GPIOD_REG + GPIO_MODER_OFFSET) |= (1 << 26); // set GPIO type 13 led out
	//IO13
	*(volatile uint32_t*)(GPIOD_REG + GPIO_MODER_OFFSET) |= (1 << 28); // set GPIO type 14 led out
	//IO14
	*(volatile uint32_t*)(GPIOD_REG + GPIO_MODER_OFFSET) |= (1 << 30); // set GPIO type 15ed out

	//Инициаилизиуем таймер 2 - для реализации системы моргания

	//Timer 2
	//Тактируем таймер
	*(volatile uint32_t*)(RCC_REG + RCC_APB1ENR_OFFSET) |= (1 << 0); // clocking tim2
	//Разрешаем прерывание от таймера в NVIC
	*(volatile uint32_t*)(NVIC_ISER0_REG) |= (1 << 28);  // interrupt in core (NVIC)
	//Ставим делитель частоты(здесь настроено на 1 миллисекунду при тактовой частоте 25 МГц)
	*(volatile uint32_t*)(TIMER2_REG + TIMER_PSC_OFFSET) = 24999; // делитель частоты
	//Ставим по умолчанию ARR как для 1го режима. MODE... - константа
	*(volatile uint32_t*)(TIMER2_REG + TIMER_ARR_OFFSET) = MODE_1_BLINK_PERIOD;
	//Разрешаем прерывание в периферии
	*(volatile uint32_t*)(TIMER2_REG + TIMER_DIER_OFFSET) |= (1 << 0); // разрешение прерывания
	//Включаем таймер!
	*(volatile uint32_t*)(TIMER2_REG + TIMER_CR1_OFFSET) |= (1 << 0);

	//Timer 3
	*(volatile uint32_t*)(RCC_REG + RCC_APB1ENR_OFFSET) |= (1 << 1); // clocking tim3
	*(volatile uint32_t*)(NVIC_ISER0_REG) |= (1 << 29);  // interrupt in core (NVIC)
	*(volatile uint32_t*)(TIMER3_REG + TIMER_PSC_OFFSET) = 24999; // делитель частоты
	*(volatile uint32_t*)(TIMER3_REG + TIMER_ARR_OFFSET) = BUTTON_NOISE_WAIT_TIME;	//Время для антидребезга
	*(volatile uint32_t*)(TIMER3_REG + TIMER_DIER_OFFSET) |= (1 << 0); // разрешение прерывания
	//Этот таймер мы включаем когда нам нужно, а не сразу, поэтому все

	USART6_StringTX("Echo: \n");

    while(1){
    	// РАБОТА С КНОПКОЙ
    	//Ждем отжатия
		if(!isBtn_waitForClick){
			if(!(*(volatile uint32_t*)(GPIOC_REG + GPIO_IDR_OFFSET) & (1 << 15))){
				isBtn_waitForClick = 1;
				isBtn_clicked = 1;
				//Включаем таймер
				*(volatile uint32_t*)(TIMER3_REG + TIMER_CR1_OFFSET) |= (1 << 0);
			}
		}
		//Ждем нажатия кнопки
		if(isBtn_clicked){
			if(*(volatile uint32_t*)(GPIOC_REG + GPIO_IDR_OFFSET) & (1 << 15)){
				if(isBtn_waitForRelease){
					isBtn_clicked = 0;
					isBtn_waitForClick = 0;
					isBtn_waitForRelease = 0;

					//Чистим этап
					ledMode++;
					if(ledMode > 7){
						ledMode = 0;
					}

					setLedMode(ledMode);
				} else{
					//Запускаем таймер вновь
					*(volatile uint32_t*)(TIMER3_REG + TIMER_CR1_OFFSET) |= (1 << 0);
					isBtn_clicked = 0;
					isBtn_waitForRelease = 1;
				}
			}
		}

		// РАБОТА С USART

    	if(USART_input_isStrReady){
    		//Эхо
			USART6_StringTX("Echo: ");
			USART6_StringTX((char*)USART_input_buffer);

    		//Если мы ожидаем частоту
    		if(isWaitingForValue){
    			//Флаг: что мы приняли, какой режим
    			uint8_t isFreqModeDetected = 0;
    			//Временный буфер для хранения полученного режима
    			uint8_t usartFrequencyMode = 1;
    			//Частотный режим 1, 2, 3
    			if(USART_input_buffer[0] == '1'){
    				isFreqModeDetected = 1;
    				usartFrequencyMode = 1;

    				USART6_StringTX("Chosen Freq Mode 1\n");
    			}
    			if(USART_input_buffer[0] == '2'){
    				isFreqModeDetected = 1;
					usartFrequencyMode = 2;

					USART6_StringTX("Chosen Freq Mode 2\n");
				}
    			if(USART_input_buffer[0] == '3'){
    				isFreqModeDetected = 1;
					usartFrequencyMode = 3;

					USART6_StringTX("Chosen Freq Mode 3\n");
				}
    			if(!isFreqModeDetected){
    				//По умолчанию режим 1
    				usartFrequencyMode = 1;

    				USART6_StringTX("Error - Undefined mode! Chosen Freq Mode 1\n");
    			}

    			//В зависимости от номера режима ставим частоту
    			switch(mode_last_registered){
    			case 4:
    				blink_mode5_frequency = usartFrequencyMode;
    				USART6_StringTX("Mode 5 configured\n");
    				break;
    			case 5:
					blink_mode6_frequency = usartFrequencyMode;
					USART6_StringTX("Mode 6 configured\n");
					break;
    			case 6:
					blink_mode7_frequency = usartFrequencyMode;
					USART6_StringTX("Mode 7 configured\n");
					break;
    			case 7:
					blink_mode8_frequency = usartFrequencyMode;
					USART6_StringTX("Mode 8 configured\n");
					break;
    			}

    			//увеличиваем счетчик режима частоты
    			mode_last_registered++;
    			//если счетсчик больше 8
    			if(mode_last_registered > 7){
    				mode_last_registered = 4;
    			}


    			isWaitingForValue = 0;
    		} else{
    			//Ожидание команд
    			//Выясняем, какая пришла команда, проверяя первые три байта посылки
				uint8_t isCommandDefined = 0;
				if(USART_input_buffer[0] == 'n'  &&
						USART_input_buffer[1] == 'e' &&
						USART_input_buffer[2] == 'w'){

					isCommandDefined = 1;

					//Для разных режимов разные массивы
					switch(mode_last_registered){
					case 4:
						blink_mode5_ActiveLeds[0] = USART_input_buffer[4];
						blink_mode5_ActiveLeds[1] = USART_input_buffer[5];
						blink_mode5_ActiveLeds[2] = USART_input_buffer[6];
						blink_mode5_ActiveLeds[3] = USART_input_buffer[7];
						blink_mode5_ActiveLeds[4] = USART_input_buffer[8];
						blink_mode5_ActiveLeds[5] = USART_input_buffer[9];
						blink_mode5_ActiveLeds[6] = USART_input_buffer[10];
						blink_mode5_ActiveLeds[7] = USART_input_buffer[11];
						break;
					case 5:
						blink_mode6_ActiveLeds[0] = USART_input_buffer[4];
						blink_mode6_ActiveLeds[1] = USART_input_buffer[5];
						blink_mode6_ActiveLeds[2] = USART_input_buffer[6];
						blink_mode6_ActiveLeds[3] = USART_input_buffer[7];
						blink_mode6_ActiveLeds[4] = USART_input_buffer[8];
						blink_mode6_ActiveLeds[5] = USART_input_buffer[9];
						blink_mode6_ActiveLeds[6] = USART_input_buffer[10];
						blink_mode6_ActiveLeds[7] = USART_input_buffer[11];
						break;
					case 6:
						blink_mode7_ActiveLeds[0] = USART_input_buffer[4];
						blink_mode7_ActiveLeds[1] = USART_input_buffer[5];
						blink_mode7_ActiveLeds[2] = USART_input_buffer[6];
						blink_mode7_ActiveLeds[3] = USART_input_buffer[7];
						blink_mode7_ActiveLeds[4] = USART_input_buffer[8];
						blink_mode7_ActiveLeds[5] = USART_input_buffer[9];
						blink_mode7_ActiveLeds[6] = USART_input_buffer[10];
						blink_mode7_ActiveLeds[7] = USART_input_buffer[11];
						break;
					case 7:
						blink_mode8_ActiveLeds[0] = USART_input_buffer[4];
						blink_mode8_ActiveLeds[1] = USART_input_buffer[5];
						blink_mode8_ActiveLeds[2] = USART_input_buffer[6];
						blink_mode8_ActiveLeds[3] = USART_input_buffer[7];
						blink_mode8_ActiveLeds[4] = USART_input_buffer[8];
						blink_mode8_ActiveLeds[5] = USART_input_buffer[9];
						blink_mode8_ActiveLeds[6] = USART_input_buffer[10];
						blink_mode8_ActiveLeds[7] = USART_input_buffer[11];
						break;
					}

					//Ставим флаг, что ждем частоту
					isWaitingForValue = 1;
					USART6_StringTX("Please, input frequency: ");
				}

				if(USART_input_buffer[0] == 's'  &&
						USART_input_buffer[1] == 'e' &&
						USART_input_buffer[2] == 't'){

					//Если 4 байт = i - значит, ждем вкл/выкл прерывания, иначе - это режим
					if(USART_input_buffer[4] == 'i'){
						//Ждем строку set interrupt on/off
						if(USART_input_buffer[14] == 'o' &&
								USART_input_buffer[15] == 'n'){
							//Разрешаем прерывания
							USART6_SetInterruptEnabled(1);
							USART6_StringTX("Interrupt enabled");
						} else{
							//Иначе выключаем
							USART6_SetInterruptEnabled(0);
							USART6_StringTX("Interrupt disabled");
						}
					} else{
						//Ждем номер режима
						//Получаем номер режима
						switch(USART_input_buffer[4]){
						case '1':
							setLedMode(0);
							break;
						case '2':
							setLedMode(1);
							break;
						case '3':
							setLedMode(2);
							break;
						case '4':
							setLedMode(3);
							break;
						case '5':
							setLedMode(4);
							break;
						case '6':
							setLedMode(5);
							break;
						case '7':
							setLedMode(6);
							break;
						case '8':
							setLedMode(7);
							break;
						default:
							USART6_StringTX("Error - Undefined mode\n");
							break;
						}
					}

					isCommandDefined = 1;
				}

				if(!isCommandDefined){
					USART6_StringTX("Error - Undefined command\n");
				}
    		}


    		//Чистим приемную строку для получения новой
    		USART_input_isStrReady = 0;
    		USART_input_str_counter = 0;
    	}


    	//ДЛЯ ОБРАБОТКИ UART БЕЗ ПРЕРЫВАНИЙ
    	USART6_Process();

    }

}

void TIM2_IRQHandler(){

	*(volatile uint32_t*)(TIMER2_REG + TIMER_SR_OFFSET) &= ~(1 << 0);

	processLedMode();
}

void processLedMode(){
	switch(ledMode){
	case 0:
		if(blink_mode1_ActiveLeds[blink_mode1_current_stage] == 'n'){
			blink_mode1_current_stage = 0;
		}
		switch_Led(blink_mode1_ActiveLeds[blink_mode1_current_stage]);
		blink_mode1_current_stage++;
		break;
	case 1:
		if(blink_mode2_ActiveLeds[blink_mode2_current_stage] == 'n'){
			blink_mode2_current_stage = 0;
		}
		switch_Led(blink_mode2_ActiveLeds[blink_mode2_current_stage]);
		blink_mode2_current_stage++;
		break;
	case 2:
		if(blink_mode3_ActiveLeds[blink_mode3_current_stage] == 'n'){
			blink_mode3_current_stage = 0;
		}
		switch_Led(blink_mode3_ActiveLeds[blink_mode3_current_stage]);
		blink_mode3_current_stage++;
		break;
	case 3:
		if(blink_mode4_ActiveLeds[blink_mode4_current_stage] == 'n'){
			blink_mode4_current_stage = 0;
		}
		switch_Led(blink_mode4_ActiveLeds[blink_mode4_current_stage]);
		blink_mode4_current_stage++;
		break;

	//Режимы с USART
	case 4:
		if(blink_mode5_ActiveLeds[blink_mode5_current_stage] == 'n'){
			blink_mode5_current_stage = 0;
		}
		switch_Led(blink_mode5_ActiveLeds[blink_mode5_current_stage]);
		blink_mode5_current_stage++;
		break;

	case 5:
		if(blink_mode6_ActiveLeds[blink_mode6_current_stage] == 'n'){
			blink_mode6_current_stage = 0;
		}
		switch_Led(blink_mode6_ActiveLeds[blink_mode6_current_stage]);
		blink_mode6_current_stage++;
		break;
	case 6:
		if(blink_mode7_ActiveLeds[blink_mode7_current_stage] == 'n'){
			blink_mode7_current_stage = 0;
		}
		switch_Led(blink_mode7_ActiveLeds[blink_mode7_current_stage]);
		blink_mode7_current_stage++;
		break;
	case 7:
		if(blink_mode8_ActiveLeds[blink_mode8_current_stage] == 'n'){
			blink_mode8_current_stage = 0;
		}
		switch_Led(blink_mode8_ActiveLeds[blink_mode8_current_stage]);
		blink_mode8_current_stage++;
		break;
	}
}

void switch_Led(char ledColour){
	switch(ledColour){
	case 'r':
		*(volatile uint32_t*)(GPIOD_REG + GPIO_ODR_OFFSET) |= (1 << 13);
		*(volatile uint32_t*)(GPIOD_REG + GPIO_ODR_OFFSET) &= ~(1 << 14);
		*(volatile uint32_t*)(GPIOD_REG + GPIO_ODR_OFFSET) &= ~(1 << 15);
		break;
	case 'g':
		*(volatile uint32_t*)(GPIOD_REG + GPIO_ODR_OFFSET) &= ~(1 << 13);
		*(volatile uint32_t*)(GPIOD_REG + GPIO_ODR_OFFSET) |= (1 << 14);
		*(volatile uint32_t*)(GPIOD_REG + GPIO_ODR_OFFSET) &= ~(1 << 15);
		break;
	case 'b':
		*(volatile uint32_t*)(GPIOD_REG + GPIO_ODR_OFFSET) &= ~(1 << 13);
		*(volatile uint32_t*)(GPIOD_REG + GPIO_ODR_OFFSET) &= ~(1 << 14);
		*(volatile uint32_t*)(GPIOD_REG + GPIO_ODR_OFFSET) |= (1 << 15);
		break;
	case 'n':
		*(volatile uint32_t*)(GPIOD_REG + GPIO_ODR_OFFSET) &= ~(1 << 13);
		*(volatile uint32_t*)(GPIOD_REG + GPIO_ODR_OFFSET) &= ~(1 << 14);
		*(volatile uint32_t*)(GPIOD_REG + GPIO_ODR_OFFSET) &= ~(1 << 15);
		break;
	}
}

//Функция установки режима моргания
void setLedMode(uint8_t mode){

	//Останавливаем таймер 2
	*(volatile uint32_t*)(TIMER2_REG + TIMER_CR1_OFFSET) &= ~(1 << 0);
	//Чистим флаг
	*(volatile uint32_t*)(TIMER2_REG + TIMER_CNT_OFFSET) = 0;

	switch(mode){
	case 0:
		USART6_StringTX("Active mode: 1\n");
		ledMode = 0;
		setLedFrequencyMode(blink_mode1_frequency);
		break;
	case 1:
		USART6_StringTX("Active mode: 2\n");
		ledMode = 1;
		setLedFrequencyMode(blink_mode2_frequency);
		break;
	case 2:
		USART6_StringTX("Active mode: 3\n");
		ledMode = 2;
		setLedFrequencyMode(blink_mode3_frequency);
		break;
	case 3:
		USART6_StringTX("Active mode: 4\n");
		ledMode = 3;
		setLedFrequencyMode(blink_mode4_frequency);
		break;
	case 4:
		USART6_StringTX("Active mode: 5\n");
		ledMode = 4;
		setLedFrequencyMode(blink_mode5_frequency);
		break;
	case 5:
		USART6_StringTX("Active mode: 6\n");
		ledMode = 5;
		setLedFrequencyMode(blink_mode6_frequency);
		break;
	case 6:
		USART6_StringTX("Active mode: 7\n");
		ledMode = 6;
		setLedFrequencyMode(blink_mode7_frequency);
		break;
	case 7:
		USART6_StringTX("Active mode: 8\n");
		ledMode = 7;
		setLedFrequencyMode(blink_mode8_frequency);
		break;
	}

	//Чтобы сразу переключало режим
	processLedMode();

	//Запускаем таймер
	*(volatile uint32_t*)(TIMER2_REG + TIMER_CR1_OFFSET) |= (1 << 0);
}

//Функция для установки режима моргания(период срабатывания таймера 2)
void setLedFrequencyMode(uint8_t mode){
	switch(mode){
	case 1:
		*(volatile uint32_t*)(TIMER2_REG + TIMER_ARR_OFFSET) = MODE_1_BLINK_PERIOD;
		break;
	case 2:
		*(volatile uint32_t*)(TIMER2_REG + TIMER_ARR_OFFSET) = MODE_2_BLINK_PERIOD;
		break;
	case 3:
		*(volatile uint32_t*)(TIMER2_REG + TIMER_ARR_OFFSET) = MODE_3_BLINK_PERIOD;
		break;
	case 4:
		*(volatile uint32_t*)(TIMER2_REG + TIMER_ARR_OFFSET) = MODE_4_BLINK_PERIOD;
		break;
	}
}

void TIM3_IRQHandler(){

	*(volatile uint32_t*)(TIMER3_REG + TIMER_SR_OFFSET) &= ~(1 << 0);

	if(isBtn_waitForRelease){
		//Если после прихода таймера до сих пор НЕактивный уровень - значит, НАЖАЛИ
		if(*(volatile uint32_t*)(GPIOC_REG + GPIO_IDR_OFFSET) & (1 << 15)){
			isBtn_clicked = 1;
		}
	} else{
		//Если после прихода таймера до сих пор активный уровень - значит, реально ОТЖАЛИ
		if(!(*(volatile uint32_t*)(GPIOC_REG + GPIO_IDR_OFFSET) & (1 << 15))){
			isBtn_clicked = 1;
		}
	}


	//Выключаем таймер
	*(volatile uint32_t*)(TIMER3_REG + TIMER_CR1_OFFSET) &= ~(1 << 0);


}

//Функция настроки системы тактирования
void SystemClockInit(){
	//Сперва используем внутренний тактовый генератор - HSI
	//Устанавливаем 0 бит в RCC_CR_OFFSET в 1 - HSION, включаем внутренний тактовый генератор на время настройки
  *(volatile uint32_t*)(RCC_REG + RCC_CR_OFFSET) |= (1 << 0); //HSION


  //Устанавливаем биты SW1 и SW2 в ноль - выбираем HSI как системный тактовый генератор(т.е. основной)
  *(volatile uint32_t*)(RCC_REG + RCC_CFGR_OFFSET) &= ~(1 << 0); //SW1
  *(volatile uint32_t*)(RCC_REG + RCC_CFGR_OFFSET) &= ~(1 << 1); //SW2

  //В регистре CR ставим в ноль биты HSE, CSS, PLL
  //CSS - система защиты частоты, она нам не нужна
  //PLL - умножитель частоты, он нам тут тоже не нужен
  //HSE пока выключаем
  *(volatile uint32_t*)(RCC_REG + RCC_CR_OFFSET) &= ~(1 << 16); //HSE OFF
  *(volatile uint32_t*)(RCC_REG + RCC_CR_OFFSET) &= ~(1 << 19); //CSS OFF
  *(volatile uint32_t*)(RCC_REG + RCC_CR_OFFSET) &= ~(1 << 24); //PLL OFF

  //Теперь начнем влючать внешний тактовый генератор - HSE
  *(volatile uint32_t*)(RCC_REG + RCC_CR_OFFSET) |= (1 << 16); //HSEON
  //Пока частота HSE не стабилизируется - виснем
  while( (*(volatile uint32_t*)(RCC_REG + RCC_CR_OFFSET) & (1 << 17)) == 0 ); // ждем стабилизации частоты HSE

  //В регистре CFGR выбираем HSE как системный тактовый генератор
  *(volatile uint32_t*)(RCC_REG + RCC_CFGR_OFFSET) |= (1 << 0); //SW1

  //Выключаем HSI
  *(volatile uint32_t*)(RCC_REG + RCC_CR_OFFSET) &= ~(1 << 0); //HSION

  //Если ВДРУГ у нас системный тактовый генератор не HSE - виснем, что-то пошло не так
  while( ( *(volatile uint32_t*)(RCC_REG + RCC_CFGR_OFFSET) & (1 << 2)) == 0 );
}
